---
import GalleryItem from './GalleryItem.astro';
import type { GalleryItemData } from './GalleryItem.astro';

export interface Props {
  title?: string;
  description?: string;
  items: GalleryItemData[];
}

const { title = 'Gallery', description, items = [] } = Astro.props as Props;
const hasSlot = Astro.slots.has('default');
const hasItems = items.length > 0;
const shouldRender = hasSlot || hasItems;
const sectionDescriptionId = description ? 'gallery-description' : undefined;
---

{shouldRender && (
  <section
    class="masonry-section"
    aria-label={title}
    aria-describedby={sectionDescriptionId}
    data-masonry-reveal
  >
    {description && (
      <p id="gallery-description" class="sr-only">
        {description}
      </p>
    )}
    <div class="masonry-grid">
      <slot />
      {items.map((item) => (
        <GalleryItem item={item} />
      ))}
    </div>
  </section>
)}

<script is:inline>
  (() => {
    if (typeof window === 'undefined') return;

    // Display gallery immediately on load while keeping the reveal animation
    const gallery = document.querySelector('[data-masonry-reveal]');
    if (!gallery) return;

    window.requestAnimationFrame(() => {
      gallery.classList.add('masonry-revealed');
    });

    const cacheLightSources = (node) => {
      if (!node.dataset.themeSrcLight) {
        const currentSrc = node.getAttribute('src');
        if (currentSrc) node.dataset.themeSrcLight = currentSrc;
      }
      if (!node.dataset.themeSrcsetLight) {
        const currentSrcset = node.getAttribute('srcset');
        if (currentSrcset) node.dataset.themeSrcsetLight = currentSrcset;
      }
    };

    const applyThemedAttributes = (node, isDark) => {
      const preferredSrc = node.getAttribute(isDark ? 'data-theme-src-dark' : 'data-theme-src-light');
      const fallbackSrc = node.getAttribute(isDark ? 'data-theme-src-light' : 'data-theme-src-dark');
      const nextSrc = preferredSrc || fallbackSrc;
      if (nextSrc && node.getAttribute('src') !== nextSrc) {
        node.setAttribute('src', nextSrc);
      }

      const preferredSrcset = node.getAttribute(isDark ? 'data-theme-srcset-dark' : 'data-theme-srcset-light');
      const fallbackSrcset = node.getAttribute(isDark ? 'data-theme-srcset-light' : 'data-theme-srcset-dark');
      const nextSrcset = preferredSrcset || fallbackSrcset;
      if (nextSrcset) {
        node.setAttribute('srcset', nextSrcset);
      } else {
        node.removeAttribute('srcset');
      }
    };

    const updateThemedImages = (theme) => {
      const isDark = theme === 'dark';
      const images = document.querySelectorAll('[data-theme-image]');
      images.forEach((node) => {
        if (node instanceof HTMLPictureElement) {
          const sources = node.querySelectorAll('source');
          sources.forEach((source) => {
            cacheLightSources(source);
            applyThemedAttributes(source, isDark);
          });
          const img = node.querySelector('img');
          if (img) {
            cacheLightSources(img);
            applyThemedAttributes(img, isDark);
          }
          return;
        }

        if (node instanceof HTMLImageElement) {
          cacheLightSources(node);
          applyThemedAttributes(node, isDark);
          const parentPicture = node.parentElement;
          if (parentPicture instanceof HTMLPictureElement) {
            const sources = parentPicture.querySelectorAll('source');
            sources.forEach((source) => {
              cacheLightSources(source);
              applyThemedAttributes(source, isDark);
            });
          }
        }
      });
    };

    const applyCurrentTheme = () => {
      const currentTheme = document.documentElement.dataset.theme || 'light';
      updateThemedImages(currentTheme);
    };

    applyCurrentTheme();
    document.addEventListener('shoebox-theme-change', (event) => {
      const nextTheme = event.detail?.theme;
      if (nextTheme) updateThemedImages(nextTheme);
    });
  })();
</script>
