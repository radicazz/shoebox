---
import '../styles/global.css';
const { title = 'Shoe Box' } = Astro.props;
const basePath = (import.meta.env.BASE_URL ?? '/').replace(/\/$/, '');
const faviconHref = `${basePath || ''}/favicon.svg`;
---
<html lang="en" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{title}</title>
    <link rel="icon" type="image/svg+xml" href={faviconHref} />
    <script is:inline>
      (function () {
        if (typeof window === 'undefined') return;
        const storageKey = 'shoebox-theme';
        const root = document.documentElement;
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');

        const applyTheme = (theme) => {
          const next = theme === 'dark' ? 'dark' : 'light';
          root.dataset.theme = next;
          root.classList.toggle('dark', next === 'dark');
          return next;
        };

        const getStored = () => {
          try {
            return localStorage.getItem(storageKey);
          } catch (error) {
            console.warn('Theme storage unavailable', error);
            return null;
          }
        };

        const storeTheme = (theme) => {
          try {
            localStorage.setItem(storageKey, theme);
          } catch (error) {
            console.warn('Unable to persist theme preference', error);
          }
        };

        const getPreferredTheme = () => {
          const storedTheme = getStored();
          if (storedTheme) return storedTheme;
          return mediaQuery.matches ? 'dark' : 'light';
        };

        const notifyThemeChange = (theme, source = 'user') => {
          document.dispatchEvent(new CustomEvent('shoebox-theme-change', { detail: { theme, source } }));
        };

        const initialTheme = applyTheme(getPreferredTheme());
        notifyThemeChange(initialTheme, getStored() ? 'user' : 'system');

        const updateToggleButton = (button, theme) => {
          if (!button) return;
          const label = button.querySelector('[data-theme-toggle-label]');
          const isDark = theme === 'dark';
          button.setAttribute('aria-pressed', String(isDark));
          if (label) {
            label.textContent = isDark ? 'Switch to light mode' : 'Switch to dark mode';
          }
        };

        const updateToggleButtonStates = (theme) => {
          const buttons = document.querySelectorAll('[data-theme-toggle]');
          buttons.forEach((btn) => updateToggleButton(btn, theme));
        };

        const handleSystemThemeChange = (event) => {
          if (getStored()) return; // user override takes precedence
          const nextTheme = event.matches ? 'dark' : 'light';
          applyTheme(nextTheme);
          notifyThemeChange(nextTheme, 'system');
          updateToggleButtonStates(nextTheme);
        };

        const bindThemeToggles = () => {
          const buttons = Array.from(document.querySelectorAll('[data-theme-toggle]'));
          const sync = () => {
            const currentTheme = window.__shoeboxTheme.get();
            buttons.forEach((btn) => updateToggleButton(btn, currentTheme));
          };
          buttons.forEach((button) => {
            button.addEventListener('click', () => {
              const next = window.__shoeboxTheme.toggle();
              updateToggleButton(button, next);
            });
          });
          document.addEventListener('shoebox-theme-change', (event) => {
            const nextTheme = event.detail?.theme;
            if (!nextTheme) return;
            buttons.forEach((btn) => updateToggleButton(btn, nextTheme));
          });
          sync();
        };

        window.__shoeboxTheme = {
          set(theme) {
            const next = applyTheme(theme);
            storeTheme(next);
            notifyThemeChange(next, 'user');
            return next;
          },
          toggle() {
            const current = root.dataset.theme === 'dark' ? 'dark' : 'light';
            const next = current === 'dark' ? 'light' : 'dark';
            return this.set(next);
          },
          clear() {
            try {
              localStorage.removeItem(storageKey);
            } catch (error) {
              console.warn('Unable to clear theme preference', error);
            }
            const next = applyTheme(getPreferredTheme());
            notifyThemeChange(next, 'system');
            updateToggleButtonStates(next);
            return next;
          },
          get() {
            return root.dataset.theme ?? 'light';
          },
        };

        const attachSystemListeners = () => {
          if (typeof mediaQuery.addEventListener === 'function') {
            mediaQuery.addEventListener('change', handleSystemThemeChange);
          } else if (typeof mediaQuery.addListener === 'function') {
            mediaQuery.addListener(handleSystemThemeChange);
          }
        };

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => {
            bindThemeToggles();
            attachSystemListeners();
            updateToggleButtonStates(window.__shoeboxTheme.get());
          });
        } else {
          bindThemeToggles();
          attachSystemListeners();
          updateToggleButtonStates(window.__shoeboxTheme.get());
        }
      })();
    </script>
  </head>
  <body class="antialiased transition-colors">
    <header class="sr-only"><h1>Shoe Box Gallery</h1></header>
    <main class="relative z-10 mx-auto w-full px-8 pb-8 pt-10 sm:px-10 sm:pt-12 lg:max-w-[92vw] 2xl:max-w-[96rem]">
      <slot />
    </main>
    <footer class="relative z-10 mx-auto w-full px-4 pb-10 text-center text-sm theme-text-muted lg:max-w-[92vw] 2xl:max-w-[96rem]">
      <span class="sr-only">made with love by cazz</span>
    </footer>
    <script is:inline>
      (function () {
        if (typeof window === 'undefined') return;
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (prefersReducedMotion) return;
        const prefersFinePointer = window.matchMedia('(pointer: fine)').matches;
        if (!prefersFinePointer) return;

        const cursor = {
          x: window.innerWidth / 2,
          y: window.innerHeight / 2,
          active: false,
        };

        const createNetwork = () => {
          const existing = document.getElementById('network-layer');
          if (existing) existing.remove();
          const canvas = document.createElement('canvas');
          canvas.id = 'network-layer';
          canvas.style.position = 'fixed';
          canvas.style.inset = '0';
          canvas.style.pointerEvents = 'none';
          canvas.style.zIndex = '0';
          canvas.style.mixBlendMode = 'normal';
          document.body.appendChild(canvas);

          const ctx = canvas.getContext('2d');
          const nodesCount = 80;
          const maxDist = 220;
          const nodes = [];

          const resize = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
          };
          resize();
          window.addEventListener('resize', resize);

          for (let i = 0; i < nodesCount; i += 1) {
            nodes.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              vx: (Math.random() - 0.5) * 0.2,
              vy: (Math.random() - 0.5) * 0.2,
              size: 1 + Math.random() * 1.5,
            });
          }

          const draw = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--network-node').trim();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--network-link').trim();
            ctx.lineWidth = 1;

            for (let i = 0; i < nodes.length; i += 1) {
              const n = nodes[i];
              n.x += n.vx;
              n.y += n.vy;
              if (n.x < 0 || n.x > canvas.width) n.vx *= -1;
              if (n.y < 0 || n.y > canvas.height) n.vy *= -1;
              ctx.beginPath();
              ctx.arc(n.x, n.y, n.size, 0, Math.PI * 2);
              ctx.fill();
            }

            for (let i = 0; i < nodes.length; i += 1) {
              for (let j = i + 1; j < nodes.length; j += 1) {
                const dx = nodes[i].x - nodes[j].x;
                const dy = nodes[i].y - nodes[j].y;
                const dist = Math.hypot(dx, dy);
                if (dist < maxDist) {
                  const alpha = 1 - dist / maxDist;
                  ctx.globalAlpha = alpha * 0.6;
                  ctx.beginPath();
                  ctx.moveTo(nodes[i].x, nodes[i].y);
                  ctx.lineTo(nodes[j].x, nodes[j].y);
                  ctx.stroke();
                }
              }
            }
            if (cursor.active) {
              for (let i = 0; i < nodes.length; i += 1) {
                const dx = nodes[i].x - cursor.x;
                const dy = nodes[i].y - cursor.y;
                const dist = Math.hypot(dx, dy);
                if (dist < maxDist) {
                  const alpha = 1 - dist / maxDist;
                  ctx.globalAlpha = alpha;
                  ctx.beginPath();
                  ctx.moveTo(nodes[i].x, nodes[i].y);
                  ctx.lineTo(cursor.x, cursor.y);
                  ctx.stroke();
                }
              }
            }
            ctx.globalAlpha = 1;
            requestAnimationFrame(draw);
          };
          draw();
        };
        const root = document.body;
        let rafId = null;

        const applyParallax = () => {
          const { innerWidth, innerHeight } = window;
          const offsetX = (0.5 - cursor.x / innerWidth) * 10;
          const offsetY = (0.5 - cursor.y / innerHeight) * 6;
          root.style.setProperty('--parallax-x', `${offsetX}px`);
          root.style.setProperty('--parallax-y', `${offsetY}px`);
        };

        const queueParallaxUpdate = () => {
          if (rafId) cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(applyParallax);
        };

        const update = (event) => {
          cursor.x = event.clientX;
          cursor.y = event.clientY;
          cursor.active = true;
          queueParallaxUpdate();
        };
        const reset = () => {
          cursor.active = false;
          cursor.x = window.innerWidth / 2;
          cursor.y = window.innerHeight / 2;
          queueParallaxUpdate();
        };
        createNetwork();
        queueParallaxUpdate();
        window.addEventListener('pointermove', update);
        window.addEventListener('pointerleave', reset);
      })();
    </script>
  </body>
</html>
